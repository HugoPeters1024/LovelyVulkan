#version 460
#extension GL_EXT_ray_tracing : enable

#include "math.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties
{
    mat4 viewInverse;
    mat4 projInverse;
    vec3 pad0;
    float time;
    vec3 pad1;
    uint tick;
    vec3 pad2;
    bool shouldReset;
} cam;

layout(location = 0) rayPayloadEXT Payload {
    vec3 normal;
    bool hit;
    vec3 materialColor;
    float d;
    vec3 emission;
} payload;


void initPayload() {
    payload.normal = vec3(0);
    payload.hit = false;
    payload.materialColor = vec3(0.0f);
    payload.d = 0.0f;
}

uint getSeed() {
    return wang_hash(wang_hash(gl_LaunchIDEXT.x + 1280u * gl_LaunchIDEXT.y) + cam.tick);
}


void main() {
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5f);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0f - 1.0f;

    vec3 origin = (cam.viewInverse * vec4(0,0,0,1)).xyz;
    vec3 target = (cam.projInverse * vec4(d.x, d.y,1,1)).xyz;
    vec3 direction = (cam.viewInverse * vec4(normalize(target), 0)).xyz;

    initPayload();

    vec3 accucolor = vec3(0);
    vec3 mask = vec3(1);
    uint seed = getSeed();

    for(int rec=0; rec<3; rec++) {
        float tmin = 0.001f;
        float tmax = 1000.0f;
        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, direction, tmax, 0);

        if (!payload.hit) break;
        if (dot(payload.normal, direction) > 0) payload.normal = -payload.normal;

        if (dot(payload.emission, payload.emission) > 0) {
            accucolor += mask * payload.emission;
            break;
        }

        origin = origin + payload.d * direction + 0.001f * payload.normal;
        direction = SampleHemisphereCosine(payload.normal, seed);
        mask *= max(0.0f, dot(payload.normal, direction));


        // Trace the shadow ray
        //const vec3 lightPos = vec3(0);
        //origin = origin + payload.d * direction + 0.001f * payload.normal;
        //const vec3 toLight = lightPos - origin;
        //const float shadowLength = length(toLight);
        //direction = toLight / shadowLength;

        // Assumption here that payload.hit must be true
        // miss shader will set it to false
        //traceRayEXT(topLevelAS, 
        //        gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT,
        //        0xff, 0, 0, 0, origin, tmin, direction, shadowLength, 0);

        //if (!payload.hit)
        //    accucolor += payload.materialColor;

        //direction = reflect(direction, payload.normal);
    }

    vec4 oldColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy));
    if (cam.shouldReset) oldColor = vec4(0);
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), oldColor + vec4(accucolor, 1));
}
