#version 460
#extension GL_EXT_ray_tracing : enable

#include "math.glsl"


layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties
{
    mat4 viewInverse;
    mat4 projInverse;
    vec4 viewDir;
    vec4 properties0;
} cam;
layout(binding = 8, set = 0) uniform sampler2D blueNoise;

float getTime() { return cam.properties0.x; }
uint getTick() { return floatBitsToUint(cam.properties0.y); }
bool getShouldReset() { return cam.properties0.z > 0.001f; }


layout(location = 0) rayPayloadEXT Payload {
    vec3 normal;
    bool hit;
    vec3 materialColor;
    float d;
    vec3 emission;
    uint customIndex;
} payload;


void initPayload() {
    payload.normal = vec3(0);
    payload.hit = false;
    payload.materialColor = vec3(0.0f);
    payload.d = 0.0f;
}

uint getSeed() {
    return wang_hash(wang_hash(gl_LaunchIDEXT.x + gl_LaunchSizeEXT.x * gl_LaunchIDEXT.y) + getTick());
}

// TODO broken (not statiscally sound)
float randBlue(inout uint seed) {
    uint blueCalls = 0;
    if (getTick() < 1) {
        seed = rand_xorshift(seed + getTick());
        vec2 sampleLoc = vec2(4 * gl_LaunchIDEXT.xy + uvec2(seed % 239, seed % 23)) / gl_LaunchSizeEXT.x;
        blueCalls++;
        return texture(blueNoise, sampleLoc).r;
    } else {
        return rand(seed);
    }
}

vec3 getSample(inout uint seed) {
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(rand(seed), rand(seed));
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0f - 1.0f;
    d.y = -d.y;

    vec3 origin = (cam.viewInverse * vec4(0,0,0,1)).xyz;
    vec3 target = (cam.projInverse * vec4(d.x, d.y,1,1)).xyz;
    vec3 direction = (cam.viewInverse * vec4(normalize(target), 0)).xyz;

    initPayload();

    vec3 accucolor = vec3(0);
    vec3 mask = vec3(1);

    for(int rec=0; rec<16; rec++) {
        float tmin = 0.001f;
        float tmax = 1000.0f;
        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, direction, tmax, 0);

        if (dot(payload.emission, payload.emission) > 0) {
            accucolor += mask * payload.emission;
            break;
        }

        if (!payload.hit) break;
        if (dot(payload.normal, direction) > 0) payload.normal = -payload.normal;

        origin = origin + payload.d * direction + 0.0001f * payload.normal;
        direction = SampleHemisphereCosine(payload.normal, rand(seed), rand(seed));
        mask *= payload.materialColor;

        // Russian roulette
        float russianP = clamp(max3(payload.materialColor), 0.1f, 0.9f);
        if (max3(mask) > 0.001f && rand(seed) < russianP) {
            mask /= russianP;
        } else {
            break;
        }


        // Trace the shadow ray
        //const vec3 lightPos = vec3(0);
        //origin = origin + payload.d * direction + 0.001f * payload.normal;
        //const vec3 toLight = lightPos - origin;
        //const float shadowLength = length(toLight);
        //direction = toLight / shadowLength;

        // Assumption here that payload.hit must be true
        // miss shader will set it to false
        //traceRayEXT(topLevelAS, 
        //        gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT,
        //        0xff, 0, 0, 0, origin, tmin, direction, shadowLength, 0);

        //if (!payload.hit)
        //    accucolor += payload.materialColor;

        //direction = reflect(direction, payload.normal);
    }

    return accucolor;
}


void main() {
    uint seed = getSeed();
    vec3 s = vec3(0);

    for(int i=0; i<15; i++)
        s += getSample(seed);
    s /= 15.0f;
    vec4 oldColor = getShouldReset() ? vec4(0) : imageLoad(image, ivec2(gl_LaunchIDEXT.xy));
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), oldColor + vec4(s, 1));
}
