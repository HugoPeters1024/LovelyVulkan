#version 460
#extension GL_EXT_ray_tracing : enable

#include "math.glsl"


layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties
{
    mat4 viewInverse;
    mat4 projInverse;
    vec4 viewDir;
    vec4 properties0;
} cam;
layout(binding = 6, set = 0) readonly buffer EmissiveTriangles { uint emissiveTriangles[]; };

float getTime() { return cam.properties0.x; }
uint getTick() { return floatBitsToUint(cam.properties0.y); }
bool getShouldReset() { return cam.properties0.z > 0.001f; }


layout(location = 0) rayPayloadEXT Payload {
    vec3 normal;
    bool hit;
    vec3 materialColor;
    float d;
    vec3 emission;
    uint customIndex;
    vec3 direction;
} payload;


void initPayload() {
    payload.normal = vec3(0);
    payload.hit = false;
    payload.materialColor = vec3(0.0f);
    payload.d = 0.0f;
}

uint getSeed() {
    return wang_hash(wang_hash(gl_LaunchIDEXT.x + gl_LaunchSizeEXT.x * gl_LaunchIDEXT.y) + getTick());
}

vec3 getSample(inout uint seed) {
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(rand(seed), rand(seed));
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0f - 1.0f;
    d.y = -d.y;

    vec3 origin = (cam.viewInverse * vec4(0,0,0,1)).xyz;
    vec3 target = (cam.projInverse * vec4(d.x, d.y,1,1)).xyz;

    initPayload();
    payload.direction = normalize((cam.viewInverse * vec4(target, 0)).xyz);

    vec3 accucolor = vec3(0);
    vec3 mask = vec3(1);
    const float tmin = 0.001f;
    const float tmax = 1000.0f;

    for(int rec=0; rec<16; rec++) {
        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, payload.direction, tmax, 0);

        if (dot(payload.emission, payload.emission) > 0) {
            accucolor += mask * payload.emission;
            break;
        }

        if (!payload.hit) break;
        payload.normal *= sign_(-dot(payload.normal, payload.direction));

        origin = origin + payload.d * payload.direction + 0.0001f * payload.normal;
        payload.direction = SampleHemisphereCosine(payload.normal, rand(seed), rand(seed));
        mask *= payload.materialColor;

        // Russian roulette
        if (!getShouldReset()) {
            const float russianP = clamp(max3(payload.materialColor), 0.1f, 0.9f);
            if (rand(seed) < russianP) {
                mask /= russianP;
            } else {
                break;
            }
        }


        // Trace the shadow ray
        //const vec3 lightPos = vec3(0);
        //origin = origin + payload.d * direction + 0.001f * payload.normal;
        //const vec3 toLight = lightPos - origin;
        //const float shadowLength = length(toLight);
        //direction = toLight / shadowLength;

        // Assumption here that payload.hit must be true
        // miss shader will set it to false
        //traceRayEXT(topLevelAS, 
        //        gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT,
        //        0xff, 0, 0, 0, origin, tmin, direction, shadowLength, 0);

        //if (!payload.hit)
        //    accucolor += payload.materialColor;

        //direction = reflect(direction, payload.normal);
    }

    return accucolor;
}


void main() {
    uint seed = getSeed();
    vec3 s = vec3(0);

    uint sampleCount = getShouldReset() ? 1 : 30;
    for(int i=0; i<sampleCount; i++)
        s += getSample(seed);
    s /= float(sampleCount);

    if (emissiveTriangles[0] != 1) {
        s = vec3(1,0,0);
    }
    vec4 oldColor = getShouldReset() ? vec4(0) : imageLoad(image, ivec2(gl_LaunchIDEXT.xy));
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), oldColor + vec4(s, 1));
}
